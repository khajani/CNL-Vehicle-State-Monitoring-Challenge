#include <WiFiS3.h>      // REQUIRED for Arduino Uno R4 WiFi networking
#include <ThingSpeak.h>  // REQUIRED for ThingSpeak functions
#include <Adafruit_LIS3MDL.h> // Magnetometer Library
#include <Adafruit_Sensor.h>  // Unified Sensor Library
#include <Wire.h>        // REQUIRED for I2C
#include <rgb_lcd.h>     // REQUIRED for LCD

// Your Team's Libraries for Sensor Processing
#include <DFRobot_BMX160.h>
#include <arduinoFFT.h>

// -------------------- 2. YOUR PRIVATE CREDENTIALS --------------------
char ssid[] = "Kj’s iPhone"; 
char pass[] = "1236393639";

// ThingSpeak Channel and API Key
unsigned long myChannelNumber = 3100192; // REPLACE with your final channel number
const char * myWriteAPIKey = "BAOHBAPAYCW24D6P"; // REPLACE with your final Write API Key

// **MAG/GPS Configuration**
const float DECLINATION_ANGLE = 12.5; // IMPORTANT: Set this for your location's magnetic variation!
const float home_magx = 160.0;    // Magnetometer baseline X
const float home_magy = -30.0;    // Magnetometer baseline Y
const float home_magz = -620.0;   // Magnetometer baseline Z
const float home_magn = 640.0;    // Magnetometer baseline Norm

// -------------------- 3. GLOBAL SYSTEM & SENSOR DEFS --------------------
WiFiClient client;
int status = WL_IDLE_STATUS;

// SENSOR OBJECTS
DFRobot_BMX160 bmx160;
rgb_lcd lcd;               
Adafruit_LIS3MDL lis3mdl; // Included as requested, though BMX160 is the primary IMU

// FFT CONFIGURATION
#define SAMPLES 256
#define SAMPLE_FREQ 400
#define IR_PIN A0
#define BANDS 8

// FFT BUFFERS
float vReal[SAMPLES];
float vImag[SAMPLES];
ArduinoFFT<float> FFT = ArduinoFFT<float>(vReal, vImag, SAMPLES, SAMPLE_FREQ);

// BASELINE DATA
float baselineSpectrum[BANDS];
bool baselineSet = false;

// GYRO/TILT CONFIG
const float gyro_scale_factor = 16384.0; // Scaling factor for +/-2G range
const float criticalAngle = 80.0;

// LCD STATE MAPPING (HLC States)
struct TestState {
  const char* anomaly;     // Anomaly type (MAX 16 CHARS)
  const char* instruction; // Actionable instruction (MAX 16 CHARS)
};

// MAPPING: currentState to the array index (0-5)
TestState states[] = {
  // Index 0: Initializing (Blue)
  {"--INIT DONE--", "LOADING DECISIONS"}, 
  // Index 1: Critical Leak (HIGHEST PRIORITY)
  {"RAD. LEAK! STOP!", "SHELTER ASAP"}, 
  // Index 2: Fire/Overheat 
  {"FIRE! CONTAIN!", "PULL OVER"},
  // Index 3: Crash/Impact 
  {"CRASH! DANGER!", "STOP, CALL CNL"},
  // Index 4: Load Shift/Warning (MEDIUM PRIORITY)
  {"LOAD SHIFTED", "STOP INSPECT"},
  // Index 5: NOMINAL (Green)
  {"SYSTEM NEUTRAL", "ALL SYSTEMS OK"},
};

int currentState = 0;      // Starts in State 0 (Initializing)
const int flashRate = 200; // milliseconds for the LCD flash cycle

// -------------------- 4. HLC (Hazard Level Check) LOGIC --------------------

int determineAnomalyState(float ir_read, float gForce_G, double fft_score, float tilt_angle, float mag_dev) {
  
  // *** HLC THRESHOLDS (ADJUST THESE VALUES CAREFULLY!) ***
  
  // CRITICAL ALERTS (Highest Priority)
  const float THRESH_RADIATION_CRITICAL = 900.0;  // High IR reading (Assuming 1024 max ADC) -> State 1
  const float THRESH_G_FORCE_CRASH      = 3.0;    // 3.0G+ is a definite crash -> State 3
  const float THRESH_OVERHEAT_CRITICAL  = 80.0;   // High Temperature (if IR is converted to Temp) -> State 2

  // WARNING ALERTS (Medium Priority - State 4)
  const float THRESH_TILT_CRITICAL      = criticalAngle; // 80.0 degrees
  const double THRESH_FFT_SEVERE        = 100000.0; // High difference score from baseline
  const float THRESH_MAG_DEVIATION      = 50.0;   // Significant magnetic change (security breach)

  
  // 1. CRITICAL RADIATION/LEAK (Highest Priority) -> State 1
  if (ir_read >= THRESH_RADIATION_CRITICAL) {
    return 1;
  }
  
  // 2. CRASH/IMPACT -> State 3
  if (gForce_G >= THRESH_G_FORCE_CRASH) {
    return 3;
  }

  // 3. FIRE/OVERHEAT -> State 2
  if (ir_read >= THRESH_OVERHEAT_CRITICAL) { 
    return 2;
  }
  
  // 4. MAJOR LOAD SHIFT / VIBRATION / SECURITY WARNING -> State 4
  if (tilt_angle >= THRESH_TILT_CRITICAL || fft_score >= THRESH_FFT_SEVERE || mag_dev >= THRESH_MAG_DEVIATION) {
    return 4;
  }
  
  // 5. NOMINAL (Lowest Priority)
  return 5;
}

// -------------------- 5. FFT HELPER FUNCTIONS (Team Code) --------------------

void collectSamples() {
  unsigned long microsPerSample = 1000000UL / SAMPLE_FREQ;
  sBmx160SensorData_t Omagn, Ogyro, Oaccel;
  
  for (int i = 0; i < SAMPLES; i++) {
    unsigned long tStart = micros();
    bmx160.getAllData(&Omagn, &Ogyro, &Oaccel); 

    // Use Z and Y axis for vibration samples
    vReal[i] = sqrt(
      (double)Oaccel.y*Oaccel.y +
      (double)Oaccel.z*Oaccel.z);

    vImag[i] = 0.0;
    while (micros() - tStart < microsPerSample);
  }

  // Remove mean
  double mean = 0.0;
  for (int i = 0; i < SAMPLES; i++) mean += vReal[i];
  mean /= SAMPLES;
  for (int i = 0; i < SAMPLES; i++) vReal[i] -= mean;
}

void runFFT() {
  FFT.windowing(FFTWindow::Hamming, FFTDirection::Forward);
  FFT.compute(FFTDirection::Forward);
  FFT.complexToMagnitude();
}

void recordBaseline() {
  collectSamples();
  runFFT();

  int binsPerBand = (SAMPLES/2) / BANDS;

  for (int b = 0; b < BANDS; b++) {
    float sum = 0;
    for (int i = b*binsPerBand; i < (b+1)*binsPerBand; i++) {
      sum += vReal[i];
    }
    baselineSpectrum[b] = sum / binsPerBand;
  }
  baselineSet = true;
}

double compareToBaseline() {
  if (!baselineSet) return 0.0;
  int binsPerBand = (SAMPLES/2) / BANDS;
  double diff = 0.0;
  
  for (int b = 0; b < BANDS; b++) {
    float sum = 0;
    for (int i = b*binsPerBand; i < (b+1)*binsPerBand; i++) {
      sum += vReal[i];
    }
    float liveAvg = sum / binsPerBand;
    float delta = liveAvg - baselineSpectrum[b];
    diff += delta * delta;
  }
  return diff;
}

// -------------------- 6. NETWORK CONNECTION FUNCTION --------------------
void connectToWiFi() {
  if (WiFi.status() == WL_NO_MODULE) {
    Serial.println("WIFI MODULE FAIL!");
    lcd.setRGB(255, 0, 0); lcd.home(); lcd.print("WIFI MODULE FAIL");
    while (true); 
  }

  while (status != WL_CONNECTED) {
    lcd.setRGB(100, 100, 255); lcd.home(); lcd.print("CONNECTING WIFI");
    lcd.setCursor(0, 1); lcd.print(ssid);
    status = WiFi.begin(ssid, pass);
    delay(10000);
  }
  Serial.println("\n✅ Connected to WiFi!");
}

// -------------------- 7. SETUP FUNCTION --------------------
void setup() {
  Serial.begin(115200); 
  lcd.begin(16, 2);
  lcd.setRGB(100, 100, 255); 
  lcd.home(); lcd.print(states[0].anomaly);
  lcd.setCursor(0, 1); lcd.print(states[0].instruction);
  
  // IMU INIT (BMX160)
  if (bmx160.begin() != true){
    Serial.println(F("BMX160 INIT FAILED!"));
    lcd.setRGB(255, 0, 0); lcd.home(); lcd.print("BMX160 FAIL!");
    while(1);
  }
  Serial.println(F("BMX160 Initialized"));
  
  // LIS3MDL Init (as requested, though BMX160 is the main source)
  if (!lis3mdl.begin_I2C()) {
    Serial.println("LIS3MDL Init FAILED! (Secondary Mag)");
  }
  
  // RECORD BASELINE
  Serial.println(F("Recording FFT Baseline..."));
  lcd.setRGB(255, 100, 0); lcd.home(); lcd.print("RECORD BASELINE");
  recordBaseline(); 
  Serial.println(F("Baseline Recorded."));

  // NETWORK INIT
  connectToWiFi();
  ThingSpeak.begin(client);

  currentState = 5; // Start in State 5 (Nominal) after successful setup
}

// -------------------- 8. MAIN LOOP FUNCTION --------------------
void loop() {
  unsigned long currentTime = millis();
  
  if (WiFi.status() != WL_CONNECTED) {
    connectToWiFi();
  }
  
  // -------------------- A. SENSOR READS & PROCESSING --------------------
  sBmx160SensorData_t Omagn, Ogyro, Oaccel;
  bmx160.getAllData(&Omagn, &Ogyro, &Oaccel);
  
  // 1. TILT / LOAD SHIFT (GYRO)
  float gyrox = Ogyro.x / gyro_scale_factor; 
  float gyroy = Ogyro.y / gyro_scale_factor;
  float gyroz = Ogyro.z / gyro_scale_factor;
  float angleTilt = max(abs(atan2(gyroy, gyroz) * 180 / PI), abs(atan2(-gyrox, sqrt(gyroy * gyroy + gyroz * gyroz)) * 180 / PI));

  // 2. IMPACT / CRASH (ACCEL)
  float accel_raw_norm = sqrt(sq(Oaccel.x) + sq(Oaccel.y) + sq(Oaccel.z));
  float gForce_in_G = accel_raw_norm / 16384.0; // Convert raw LSB to G's

  // 3. VIBRATION / INTEGRITY (FFT)
  collectSamples();
  runFFT(); 
  double freq_diff = compareToBaseline();
  const float alpha = 0.2;
  static double smooth_diff = 0;
  smooth_diff = alpha * freq_diff + (1 - alpha) * smooth_diff; // FFT_SCORE

  // 4. MAGNETOMETER (SECURITY)
  float magx = Omagn.x;
  float magy = Omagn.y; 
  float magz = Omagn.z;
  float magn = sqrt(sq(magx) + sq(magy) + sq(magz));
  float d_magn = abs(magn - home_magn); // Deviation score
  
  // 5. IR / EXTERNAL SENSOR (FIRE/RADIATION)
  float ir_read = analogRead(IR_PIN); 
  
  // --- GPS PLACEHOLDERS ---
  float latitude_value = 43.41; 
  float longitude_value = -80.52; 

  // --- TRUE HEADING CALCULATION ---
  float raw_heading = atan2(magy, magx) * 180.0 / PI;
  float true_heading = raw_heading + DECLINATION_ANGLE;
  if (true_heading < 0) {
    true_heading += 360;
  }
  
  // -------------------- B. STATE DETERMINATION (HLC Execution) --------------------
  currentState = determineAnomalyState(ir_read, gForce_in_G, smooth_diff, angleTilt, d_magn);
  
  // -------------------- C. LCD DISPLAY LOGIC --------------------
  TestState current = states[currentState];

  // Flashing RED for CRITICAL states (1, 2, 3, 4)
  if (currentState >= 1 && currentState <= 4) {
    if (currentTime % flashRate < (flashRate / 2)) {  
        lcd.setRGB(255, 0, 0); // Red
    } else {
        lcd.setRGB(0, 0, 0); // Off 
    }
  } 
  // Fixed GREEN for NOMINAL (State 5)
  else if (currentState == 5) {
    lcd.setRGB(0, 255, 0); // Green
  }
  
  // Always update the display content
  lcd.home();
  lcd.print(current.anomaly);
  lcd.setCursor(0, 1);
  lcd.print(current.instruction);
  
  // -------------------- D. THINGSPEAK SEND --------------------
  
  // --- SET UP FIELDS ---
  ThingSpeak.setField(1, ir_read);        // Field 1: IR/Radiation/Temp Analog Read
  ThingSpeak.setField(2, gForce_in_G);    // Field 2: Max G-force (Impact)
  ThingSpeak.setField(3, smooth_diff);    // Field 3: FFT Vibration Score
  ThingSpeak.setField(4, angleTilt);      // Field 4: Tilt Angle (Load Shift)
  ThingSpeak.setField(5, latitude_value); // Field 5: Latitude
  ThingSpeak.setField(6, longitude_value);// Field 6: Longitude
  ThingSpeak.setField(7, d_magn);         // Field 7: Mag Deviation (Security)
  ThingSpeak.setField(8, currentState);   // Field 8: HLC Final State (Most Critical)
  
  // Print to Serial for debugging
  Serial.println("\n--- TELE-RISK Status ---");
  Serial.print("State: "); Serial.print(currentState); Serial.print(" - "); Serial.println(current.anomaly);
  Serial.print("F2 (gForce): "); Serial.println(gForce_in_G);
  Serial.print("F3 (FFT Score): "); Serial.println(smooth_diff);
  Serial.print("F4 (Tilt): "); Serial.println(angleTilt);
  Serial.print("F8 (HLC State): "); Serial.println(currentState);

  // WRITE DATA TO THINGSPEAK
  int http_response_code = ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey);

  if (http_response_code == 200) {
    Serial.println("✅ Data sent successfully! (HTTP 200)");
  } else {
    Serial.print("❌ Problem updating channel. HTTP error code: ");
    Serial.println(http_response_code);
  }

  delay(20000); // 20-second update cycle
}
