// GLOBAL LIBRARIES 
#include <WiFiS3.h>      // REQUIRED for Arduino Uno R4 WiFi networking
#include <ThingSpeak.h>  // REQUIRED for ThingSpeak functions
#include <Adafruit_LIS3MDL.h> // Magnetometer Library
#include <Adafruit_Sensor.h>  // Unified Sensor Library
#include <Wire.h>        // REQUIRED for I2C (LCD and Mag)
#include <rgb_lcd.h>     // REQUIRED for LCD

// YOUR PRIVATE CREDENTIALS 
char ssid[] = "Kj’s iPhone"; 
char pass[] = "1236393639";

// ThingSpeak Channel and API Key
unsigned long myChannelNumber = 3100192;
const char * myWriteAPIKey = "BAOHBAPAYCW24D6P"; 
const float DECLINATION_ANGLE = 12.5; // <<-- IMPORTANT: CHANGE THIS TO YOUR LOCATION'S ACC VALUE!

// GLOBAL VARIABLES
WiFiClient client;
int status = WL_IDLE_STATUS;

// SENSOR OBJECTS
Adafruit_LIS3MDL lis3mdl; // Magnetometer object
rgb_lcd lcd;               // LCD object

// LCD STATE VARIABLES
struct TestState {
  const char* anomaly;     // Anomaly type (MAX 16 CHARS)
  const char* instruction; // Actionable instruction (MAX 16 CHARS)
};

// **TEXT 16 CHARACTERS OR LESS**
// MAPPING: currentState to the array index (1-5)
TestState states[] = {
  // Index 0: Initializing (Blue)
  {"--INIT DONE--", "LOADING DECISIONS"}, 
  // Index 1: Radiation Leak Instruction (CRITICAL - Red Flash)
  {"RAD. LEAK! STOP!", "SHELTER ASAP"}, 
  // Index 2: Fire/Overheat Instruction (CRITICAL - Red Flash)
  {"FIRE! CONTAIN!", "PULL OVER"},
  // Index 3: Crash/Impact Instruction (CRITICAL - Red Flash)
  {"CRASH! DANGER!", "STOP, CALL CNL"},
  // Index 4: Load Shift/Other Generic Warning (CRITICAL - Red Flash)
  {"LOAD SHIFTED", "STOP INSPECT"},
  // Index 5: NOMINAL (Green)
  {"SYSTEM NEUTRAL", "ALL SYSTEMS OK"},
};

const int numStates = sizeof(states) / sizeof(states[0]);
int currentState = 0; // Starts in State 0 (Initializing)
const int flashRate = 200; // milliseconds for the LCD flash cycle

// FUNCTION: determineAnomalyState 
// This function determines the current alert state based on sensor readings
// The priority is: Radiation > Crash > Fire > Load Shift > Neutral
// MUST replace the placeholder variables (temp, gForce, score) w/ acc values
int determineAnomalyState(float temp_C, float gForce_G, float rad_score) {
  
  // PLACEHOLDER THRESHOLDS (ADJUST THESE LATER)
  const float HIGH_RADIATION_THRESHOLD = 500.0; // Assume 500+ is a critical leak
  const float HIGH_G_FORCE_THRESHOLD   = 2.5;   // Assume 2.5G+ is a crash
  const float OVERHEAT_TEMP_THRESHOLD  = 80.0;  // Assume 80C+ is fire/overheat
  const float LOAD_SHIFT_SCORE         = 100.0; // Assume a calculated score of 100+ is load shift
  
  // 1. RADIATION LEAK (Highest Priority) -> State 1
  if (rad_score >= HIGH_RADIATION_THRESHOLD) {
    return 1; 
  }

  // 2. CRASH/IMPACT (High Priority) -> State 3
  if (gForce_G >= HIGH_G_FORCE_THRESHOLD) {
    return 3;
  }
  
  // 3. FIRE/OVERHEAT -> State 2
  if (temp_C >= OVERHEAT_TEMP_THRESHOLD) {
    return 2; 
  }
  
  // 4. LOAD SHIFT/GENERIC WARNING -> State 4
  // NOTE: This usually comes from a complex fusion score (Field 1)
  if (rad_score >= LOAD_SHIFT_SCORE) { 
    return 4;
  }

  // 5. NOMINAL (Lowest Priority) -> State 5
  return 5;
}


// FUNCTION: connectToWiFi (Same as before) 
void connectToWiFi() {
  if (WiFi.status() == WL_NO_MODULE) {
    // ... error logic ...
    lcd.setRGB(255, 0, 0); lcd.home(); lcd.print("WIFI MODULE FAIL");
    while (true); 
  }

  while (status != WL_CONNECTED) {
    Serial.print("Attempting to connect to SSID: ");
    Serial.println(ssid);
    lcd.setRGB(100, 100, 255); lcd.home(); lcd.print("CONNECTING WIFI");
    lcd.setCursor(0, 1); lcd.print(ssid);

    status = WiFi.begin(ssid, pass);
    delay(10000);
  }

  Serial.println("\n✅ Connected to WiFi!");
}

// SETUP FUNCTION (Same as before) 
void setup() {
  Serial.begin(115200); 
  delay(100);

  lcd.begin(16, 2);
  lcd.setRGB(100, 100, 255); 
  lcd.home(); lcd.print(states[0].anomaly);
  lcd.setCursor(0, 1); lcd.print(states[0].instruction);

  connectToWiFi();
  ThingSpeak.begin(client);

  Serial.print("Initializing LIS3MDL...");
  if (!lis3mdl.begin_I2C()) {
    Serial.println("...FAILED! Check wiring/address. Halting.");
    lcd.setRGB(255, 0, 0); lcd.home(); lcd.print("MAG INIT FAILED!");
    while (1) delay(10);
  }
  lis3mdl.setOperationMode(LIS3MDL_MEDIUMMODE);
  Serial.println("...SUCCESS!");

  currentState = 5; // Start in State 5 (Nominal) after successful setup
}

// MAIN LOOP FUNCTION 
void loop() {
  unsigned long currentTime = millis();
  
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("Lost WiFi connection. Reconnecting...");
    connectToWiFi();
  }
  
  // SENSOR READS 
  sensors_event_t event;
  lis3mdl.getEvent(&event);
  
  // RAW MAGNETOMETER DATA 
  float mag_x = event.magnetic.x; // Value for Field 6
  float mag_y = event.magnetic.y; // Value for Field 7
  
  // PLACEHOLDER SENSOR READS (REPLACE THESE LINES LATER!) ---
  // These must be replaced with your team's actual functions.
  float rad_anomaly_score = 45.0; // Placeholder for Field 1 (Score)
  float gForce_in_G       = 1.05; // Placeholder for Field 2 (gforce)
  float temperature_C     = 25.0; // Placeholder for Field 3 (temp)
  float latitude_value    = 43.41; // Placeholder for Field 4 (latitude)
  float longitude_value   = -80.52; // Placeholder for Field 5 (longitude)
  
  // TRUE HEADING CALCULATION (for Field 8) ---
  float raw_heading = atan2(mag_y, mag_x) * 180.0 / PI;
  float true_heading = raw_heading + DECLINATION_ANGLE;
  if (true_heading < 0) {
    true_heading += 360;
  }

  // STATE DETERMINATION 
  currentState = determineAnomalyState(temperature_C, gForce_in_G, rad_anomaly_score);
  
  // LCD DISPLAY LOGIC 
  TestState current = states[currentState];

  // If NOT NEUTRAL (State 1 through 4) - Flashing RED
  if (currentState >= 1 && currentState <= 4) {
    if (currentTime % flashRate < (flashRate / 2)) {  
        lcd.setRGB(255, 0, 0); // Red
    } else {
        lcd.setRGB(0, 0, 0); // Off 
    }
  } 
  // If NEUTRAL (State 5) - Fixed GREEN
  else if (currentState == 5) {
    lcd.setRGB(0, 255, 0); // Green
  }
  
  // Always update the display content
  lcd.home();
  lcd.print(current.anomaly);
  lcd.setCursor(0, 1);
  lcd.print(current.instruction);
  
  // THINGSPEAK CONNECTION
  
  // SET UP FIELDS 
  // Core Project Fields (Now using placeholders)
  ThingSpeak.setField(1, rad_anomaly_score); // Field 1: Score
  ThingSpeak.setField(2, gForce_in_G);       // Field 2: gforce
  ThingSpeak.setField(3, temperature_C);      // Field 3: temp
  ThingSpeak.setField(4, latitude_value);    // Field 4: latitude
  ThingSpeak.setField(5, longitude_value);   // Field 5: longitude
  
  // MAGNETOMETER AND HEADING FIELDS
  ThingSpeak.setField(6, mag_x);
  ThingSpeak.setField(7, mag_y);
  ThingSpeak.setField(8, true_heading); // Field 8: True Heading
  
  // Print to Serial
  Serial.println("\n--- Sensor Readings ---");
  Serial.print("Current State: "); Serial.print(currentState); Serial.print(" - "); Serial.println(current.anomaly);
  Serial.print("F1 (Score): "); Serial.println(rad_anomaly_score);
  Serial.print("F2 (gForce): "); Serial.println(gForce_in_G);
  Serial.print("F3 (Temp): "); Serial.println(temperature_C);
  Serial.print("F8 (Heading): "); Serial.println(true_heading);
  
  // WRITE DATA TO THINGSPEAK 
  int http_response_code = ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey);

  if (http_response_code == 200) {
    Serial.println("✅ Data sent successfully! (HTTP 200)");
  } else {
    Serial.print("❌ Problem updating channel. HTTP error code: ");
    Serial.println(http_response_code);
  }

  delay(20000); 
}
